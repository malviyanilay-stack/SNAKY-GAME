<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SNAKEY SNAKEY</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <style>
    body { background: #101722; margin: 0; font-family: sans-serif; overflow:hidden;}
    #game { background:#181E2A; margin:24px auto 0; display:block; border:3px solid #2f8; box-shadow:0 0 40px #2f8b; }
    #score { color: #2f8; text-align: center; font-size: 2em; padding-top:10px;}
    #scoreboard {
      background:rgba(16,28,48,0.93);
      color:#fff; position:fixed;top:5px;right:12px;z-index:3;
      border:2px solid #2f8;border-radius:10px;padding:14px;font-size:1.1em;
      min-width:160px;max-width:230px; letter-spacing:0.5px;
      box-shadow:0 2px 24px #1d276430;
    }
    #scoreboard h3 {margin:0 0 8px 0;color:#eaf8a7;font-weight:normal;}
    #touches { position:fixed;bottom:12px;left:0;right:0;text-align:center;z-index:2;}
    .btn {width:66px;height:66px;margin:8px;background:linear-gradient(146deg,#383,#2a5);border:2px solid #af8;border-radius:50%;display:inline-block;line-height:66px;font-size:2em;color:#fff;user-select:none;box-shadow:0 2px 6px #141;}
    .btn:active{background:linear-gradient(146deg,#2f7,#18d);}
    #joystick {
      position:fixed; left:30px; bottom:30px; width:110px; height:110px; z-index:10;
      touch-action:none; user-select:none; opacity:0.96;
      display:none;
    }
    #joystick.hidden { display:none; }
    #joystick .circle {
      position:absolute; left:0; top:0; width:110px; height:110px; border-radius:50%;
      background:rgba(100,255,180,0.07); border:2.5px solid #2fd6ae;
      box-shadow: 0 0 16px #1af3, 0 0 60px #0e4;
    }
    #joystick .stick {
      position:absolute; left:37px; top:37px; width:36px; height:36px; border-radius:50%;
      background:radial-gradient(circle at 30% 30%, #fff 70%, #1dffc5 96%, #0cbf9c 100%);
      border:1.5px solid #23cec7; box-shadow:0 3px 12px #24d8a0;
    }
  </style>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
  <div id="scoreboard"></div>
  <canvas id="game" width="680" height="680"></canvas>
  <div id="score"></div>
  <div id="touches">
    <div class="btn" id="btnLeft">&#8592;</div>
    <div class="btn" id="btnUp">&#8593;</div>
    <div class="btn" id="btnDown">&#8595;</div>
    <div class="btn" id="btnRight">&#8594;</div>
  </div>
  <div id="joystick" class="hidden">
    <div class="circle"></div>
    <div class="stick"></div>
  </div>
<script>
const socket = io('https://supreme-octo-palm-tree-5x9j.onrender.com/');

const GRID_SIZE = 40, scale = 17, rows = GRID_SIZE, cols = GRID_SIZE;
const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d');
const center = {x: Math.floor(cols/2), y: Math.floor(rows/2)};

const roomName = prompt("Room name?") || "default";
const playerName = prompt("Your nickname?") || "anon";
socket.emit("joinRoom", {room:roomName, name:playerName});

let score=0, gameOver=false, moveLock=false;
let players = {}, foods = [{x:10,y:10}];
let mySnake = [Object.assign({}, center)];
let lastDir = "right", nextDir = "right";
let discoTime = 0;

function hashNick(nick) {
  let hash = 0;
  for(let i=0;i<nick.length;i++) {
    hash = ((hash<<5)-hash) + nick.charCodeAt(i);
    hash |=0;
  }
  return Math.abs(hash);
}
function playerColor(seed){
  const hues = [130,210,45,0,288,355,60,280,180,96,165,330];
  let idx = (seed||0)%hues.length;
  const h = hues[idx], s=90, l=53;
  return `hsl(${h},${s}%,${l}%)`;
}
function playerShadowColor(seed){
  const hues = [130,210,45,0,288,355,60,280,180,96,165,330];
  let idx = (seed||0)%hues.length;
  const h = hues[idx], s=96, l=56;
  return `hsl(${h},${s}%,${l}%)`;
}
function getPlayerListSorted() {
  return Object.values(players).sort((a,b)=>b.score-a.score||a.joined-b.joined);
}
function drawGrid(){
  ctx.save();
  ctx.strokeStyle="#263038";
  ctx.lineWidth=0.7;
  for(let x=1;x<cols;x++){
    ctx.beginPath();ctx.moveTo(x*scale,0);ctx.lineTo(x*scale,canvas.height);ctx.stroke();
  }
  for(let y=1;y<rows;y++){
    ctx.beginPath();ctx.moveTo(0,y*scale);ctx.lineTo(canvas.width,y*scale);ctx.stroke();
  }
  ctx.restore();
}
function drawFood(f){
  const cx = f.x*scale+scale/2, cy = f.y*scale+scale/2, r = scale*0.5;
  let grad = ctx.createRadialGradient(cx,cy,3,cx,cy,r);
  grad.addColorStop(0, "#fffbbb");
  grad.addColorStop(0.18, "#eaff43");
  grad.addColorStop(0.65, "#ff8040");
  grad.addColorStop(1, "rgba(255,80,40,0.02)");
  ctx.save();
  ctx.globalAlpha = 0.99;
  ctx.beginPath();ctx.arc(cx,cy,r,0,2*Math.PI);
  ctx.fillStyle = grad;
  ctx.shadowColor = "#fff661";
  ctx.shadowBlur = 18;
  ctx.fill();
  ctx.restore();
}
function getDiscoColor(t){
  let hue = (t*200)%360;
  return `hsl(${hue},99%,60%)`;
}
function getDiscoGradient(x,y,radius,t){
  let grad = ctx.createRadialGradient(x,y,2,x,y,radius);
  grad.addColorStop(0.0,"#fff");
  grad.addColorStop(0.23, getDiscoColor(t));
  grad.addColorStop(0.99, "rgba(255,255,255,0)");
  return grad;
}
function drawSnakeDisco(p){
  let t = discoTime;
  for(let i=p.snake.length-1;i>=0;i--){
    let seg = p.snake[i];
    let cx = seg.x*scale+scale/2, cy = seg.y*scale+scale/2;
    if(i===0){
      let grad = getDiscoGradient(cx,cy,scale/1.13,t);
      ctx.save();
      ctx.beginPath();ctx.arc(cx,cy,scale*0.56,0,2*Math.PI);
      ctx.globalAlpha=1.0;
      ctx.fillStyle=grad; ctx.shadowBlur=21; ctx.shadowColor=getDiscoColor(t+0.1);
      ctx.fill();
      ctx.lineWidth=2.6; ctx.strokeStyle=getDiscoColor(t+0.3);
      ctx.stroke();
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalAlpha = Math.max(0.72-0.012*i,0.33);
      ctx.beginPath();
      ctx.arc(cx,cy,scale*0.46,0,2*Math.PI);
      ctx.fillStyle = getDiscoColor(t+0.13*i);
      ctx.shadowColor = getDiscoColor(t+0.23*i);
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.restore();
    }
  }
}
function drawSnakeNormal(p){
  let seed = p.colorSeed||0;
  let col = playerColor(seed), shad = playerShadowColor(seed);
  for(let i=p.snake.length-1;i>=0;i--){
    let seg = p.snake[i];
    let cx = seg.x*scale+scale/2, cy = seg.y*scale+scale/2;
    if(i===0){
      let g = ctx.createRadialGradient(cx,cy,3,cx,cy,scale/1.21);
      g.addColorStop(0.0,"#fafafa");
      g.addColorStop(0.48,col);
      g.addColorStop(1.0,"rgba(47,255,170,0)");
      ctx.save();
      ctx.globalAlpha=1.0;
      ctx.beginPath();
      ctx.arc(cx,cy,scale*0.55,0,2*Math.PI);
      ctx.fillStyle=g;
      ctx.lineWidth=2;
      ctx.strokeStyle=col;
      ctx.shadowBlur=7; ctx.shadowColor=shad;
      ctx.fill(); ctx.stroke();
      ctx.restore();
    }else{
      ctx.save();
      ctx.globalAlpha=Math.max(0.7-0.014*i,0.3);
      ctx.beginPath(); ctx.arc(cx,cy,scale*0.44,0,2*Math.PI);
      ctx.fillStyle=col;
      ctx.shadowColor=shad;
      ctx.shadowBlur=5;
      ctx.fill();
      ctx.restore();
    }
  }
}
function drawSnakesAndNames(){
  const sorted = getPlayerListSorted();
  discoTime = Date.now()/1000;
  sorted.forEach((p)=>{
    if(p.disco) drawSnakeDisco(p);
    else drawSnakeNormal(p);
  });
  sorted.forEach((p)=>{
    let head=p.snake[0];let cx=head.x*scale+scale/2,cy=head.y*scale+scale/2;
    ctx.save();
    ctx.font="bold 12px sans-serif";
    if(p.disco)
      ctx.fillStyle=getDiscoColor(discoTime+0.2);
    else
      ctx.fillStyle=playerColor(p.colorSeed);
    ctx.textAlign="center";
    ctx.shadowColor="#000";ctx.shadowBlur=2;
    ctx.fillText(p.name+(p.id===socket.id?' (you)':''),cx,cy-11);
    ctx.restore();
  });
}
function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawGrid();
  foods.forEach(drawFood);
  drawSnakesAndNames();
  document.getElementById('score').textContent =
    gameOver ? "Game Over! Tap/click/press any direction or joystick to restart" : "Score: "+score;
}
function drawScoreboard() {
  let html = `<h3>Scoreboard</h3>`;
  let items = getPlayerListSorted()
    .map((p)=>`<b style="color:${p.disco?getDiscoColor(discoTime):"#ffe024"}">${p.score}</b> â€“ <span style="color:${p.disco?getDiscoColor(discoTime):"#42dffb"}">${p.name}${p.id===socket.id?' (you)':''}</span>`);
  if(items.length === 0) items.push('-');
  document.getElementById('scoreboard').innerHTML = html + items.join("<br>");
}
function moveAllowedDir(d) {
  return ((d==="up" && lastDir!=="down") ||
         (d==="down" && lastDir!=="up") ||
         (d==="left" && lastDir!=="right") ||
         (d==="right" && lastDir!=="left"));
}
function requestMove(d) {
  if(gameOver){ restart(); return; }
  if(moveLock) return;
  if(moveAllowedDir(d)) {
    nextDir = d;
    moveSnake();
  }
}
["Left","Up","Down","Right"].forEach(d=>{
  document.getElementById("btn"+d).ontouchstart =
  document.getElementById("btn"+d).onclick = ()=>requestMove(d.toLowerCase());
});
document.addEventListener('keydown', function(e) {
  let key = e.key.toLowerCase();
  if(key==="arrowup"||key==="w")requestMove("up");
  else if(key==="arrowdown"||key==="s")requestMove("down");
  else if(key==="arrowleft"||key==="a")requestMove("left");
  else if(key==="arrowright"||key==="d")requestMove("right");
});
// --- JOYSTICK ---
const joystick = document.getElementById('joystick');
const stick = joystick.querySelector('.stick');
const circle = joystick.querySelector('.circle');
let joyActive = false, joyStart={x:0,y:0};
function showJoystick(){
  if(window.innerWidth<900){
    joystick.style.display="";
    joystick.classList.remove("hidden");
  }
}
function hideJoystick(){
  joystick.style.display="none";
  joystick.classList.add("hidden");
}
function getJoyDir(dx,dy){
  if(Math.abs(dx)>Math.abs(dy)){
    return dx>7?"right":dx<-7?"left":null;
  }else{
    return dy>7?"down":dy<-7?"up":null;
  }
}
circle.addEventListener('touchstart', e=>{
  joyActive=true;
  let rect=joystick.getBoundingClientRect();
  let t=e.touches[0];
  joyStart.x=t.clientX-rect.left; joyStart.y=t.clientY-rect.top;
  stick.style.left=(joyStart.x-18)+"px"; stick.style.top=(joyStart.y-18)+"px";
}, {passive:false});
circle.addEventListener('touchmove', e=>{
  if(!joyActive)return;
  e.preventDefault();
  let rect=joystick.getBoundingClientRect();
  let t=e.touches[0];
  let x=t.clientX-rect.left, y=t.clientY-rect.top;
  let dx = x-joyStart.x, dy = y-joyStart.y;
  stick.style.left=(x-18) + "px"; stick.style.top=(y-18)+"px";
  let dir=getJoyDir(dx,dy);
  if(dir) { requestMove(dir); joyActive=false; setTimeout(resetJoy,100);}
}, {passive:false});
function resetJoy(){
  stick.style.left="37px";stick.style.top="37px";
  joyActive=false;
}
circle.addEventListener('touchend', ()=>{ resetJoy(); });
if(/android|iphone|ipad|ipod|mobile|touch/i.test(navigator.userAgent)){
  showJoystick();
} else {
  hideJoystick();
}
function moveSnake(){
  if(gameOver) return;
  moveLock = true;
  let head = {...mySnake[0]};
  lastDir = nextDir;
  if(lastDir=="up") head.y--;
  if(lastDir=="down") head.y++;
  if(lastDir=="left") head.x--;
  if(lastDir=="right") head.x++;
  if(head.x<0||head.x>=cols||head.y<0||head.y>=rows
     || mySnake.some(p=>p.x==head.x&&p.y==head.y)) {
    gameOver=true; draw(); drawScoreboard(); moveLock=false;
    return;
  }
  let ateFood = false, eatenIndex = -1;
  foods.forEach((f,idx) => {
    if(head.x==f.x && head.y==f.y) {
      ateFood = true;
      eatenIndex = idx;
    }
  });
  let snakeAfter = [head, ...mySnake];
  if(ateFood) {
    score++;
    foods.splice(eatenIndex,1);
    socket.emit("eatFood", {x: head.x, y: head.y});
  } else {
    snakeAfter.pop();
  }
  socket.emit("update", {snake: snakeAfter, score: score});
}
function restart(){
  nextDir = "right"; lastDir = "right"; score=0; gameOver=false;
  mySnake = [Object.assign({}, center)];
  moveLock = false;
  socket.emit("restart");
  draw(); drawScoreboard();
}
socket.on("gameState", data => {
  players = data.players || {};
  if(Array.isArray(data.foods)) foods = data.foods;
  else if(data.food) foods = [data.food];
  else foods = [];
  let me = players[socket.id];
  if(me){
    mySnake = me.snake;
    score = me.score;
  }
  draw(); drawScoreboard();
  moveLock = false;
});
socket.on("dead", ()=>{
  gameOver=true; moveLock=false; draw(); drawScoreboard();
});
setInterval(()=>{
  if(getPlayerListSorted().length>0) {
    drawScoreboard();
    draw();
  }
},75);
</script>
</body>
</html>
